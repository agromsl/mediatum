"""
 mediatum - a multimedia content repository

 Copyright (C) 2007 Arne Seifert <seiferta@in.tum.de>
 Copyright (C) 2007 Matthias Kramm <kramm@in.tum.de>

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""
import sys
import os
import re
import time
import urllib
import json
import traceback
import core.tree as tree
import core.config as config
import core.help as help
import core.users as users
import core.usergroups as usergroups
import core.translation
import core.athana as athana
import utils.log
import logging
from core.acl import AccessData
from utils.utils import Link, isCollection, Menu, getFormatedString, splitpath, parseMenuString, isDirectory

from edit_common import *

from core.translation import lang
from core.translation import t as translation_t

from edit_common import EditorNodeList
from core.datatypes import loadAllDatatypes, Datatype
from core.tree import getRoot, nodes_cache, childids_cache, parentids_cache
from schema.schema import loadTypesFromDB
from utils.utils import funcname

from pprint import pprint as pp, pformat as pf

logger = logging.getLogger('editor')


containertypes = []

def clearFromCache(node):
    for n in node.getAllChildren():
        nodes_cache.remove(int(n.id))
        childids_cache[int(n.id)] = None
        parentids_cache[int(n.id)] = None


def getContainerTreeTypes(req):
    '''
    function only called to fill context menues for editor tree
    '''
    global containertypes
    containertypes = []
    def getDatatypes(req):
        dtypes = []
        for scheme in AccessData(req).filter(loadTypesFromDB()):
            dtypes += scheme.getDatatypes()
        return set(dtypes)
        
    if 1:  #len(containertypes)==0:
        dtypes = getDatatypes(req)

        for dtype in loadAllDatatypes():
            if dtype.name in dtypes:
                n = tree.Node("", type=dtype.name) 
                if hasattr(n, "isContainer") and hasattr(n, "isSystemType"): 
                    if n.isContainer() and not n.isSystemType():
                        if dtype not in containertypes:
                            containertypes.append(dtype)
    
    ct_names = [ct.name for ct in containertypes]
    #Datatype(key, key, cls.__name__, cls.__module__+'.'+cls.__name__)
    for key in ['collection', 'directory']:
        prefix = 'bare_'
        # user should be able to create collection and directory containers to
        # have a functinal system. in a completly empty mediatum there will be no 
        # metadatatypes (schemata) for those. they are inserted here on-the-fly
        # as bare_collection, bare_directory
        if key not in ct_names:
            containertypes.append(Datatype(prefix+key, prefix+key, 'no_class', 'generated on-the-fly for editor to provide name for context_menue'))
    
    return containertypes


def getContainerTreeTypes_orig(req):
    def getDatatypes(req):
        dtypes = []
        for scheme in AccessData(req).filter(loadTypesFromDB()):
            dtypes += scheme.getDatatypes()
        return set(dtypes)
        
    if len(containertypes)==0:
        dtypes = getDatatypes(req)

        for dtype in loadAllDatatypes():
            if dtype.name in dtypes:
                n = tree.Node("", type=dtype.name) 
                if hasattr(n, "isContainer") and hasattr(n, "isSystemType"): 
                    if n.isContainer() and not n.isSystemType():
                        containertypes.append(dtype)
    return containertypes


def getTreeLabel(node):
    try:
        label = node.getLabel()
    except:
        label = node.getName()
    
    c = len(node.getContentChildren())
    if c>0:
        label += ' <small>(%s)</small>' %(c)
    return label



def frameset(req):
    id = req.params.get("id", tree.getRoot("collections").id)
    tab = req.params.get("tab", None)

    try:
        currentdir = tree.getNode(id)
    except tree.NoSuchNodeError:
        currentdir = tree.getRoot("collections")
        req.params["id"] = currentdir.id
        id = req.params.get("id")
        
    path = []
    n = currentdir
    while n:
        path = ['%s' % (n.id)] + path
        p = n.getParents()
        if p: n = p[0]
        else: n = None
        
        
    user = users.getUserFromRequest(req)
    menu = filterMenu(getEditMenuString(currentdir.getContentType()), user)
    
    spc = [Menu("sub_header_frontend", "../", target="_parent")]  
    if user.isAdmin():
        spc.append(Menu("sub_header_administration", "../admin", target="_parent"))
        
    if user.isWorkflowEditor():
        spc.append(Menu("sub_header_workflow", "../publish", target="_parent"))

    spc.append(Menu("sub_header_logout", "../logout", target="_parent"))
    
    def getPathToFolder(node):
        n = node
        path = []
        while n:
            path = ['/%s' % (n.id)] + path
            p = n.getParents()
            if p: n = p[0]
            else: n = None
        return (node, "".join(path[2:]))
    
    folders = {'homedir':getPathToFolder(users.getHomeDir(user)), 'trashdir': getPathToFolder(users.getSpecialDir(user, 'trash')), 'uploaddir': getPathToFolder(users.getSpecialDir(user, 'upload')), 'importdir': getPathToFolder(users.getSpecialDir(user, 'import'))}
    
    access = AccessData(req)
    if not access.getUser().isEditor():
        req.writeTAL("web/edit/edit.html", {}, macro="edit_notree_permission")
        return

    v = {
          "id": id, 
          "tab": (tab and "&tab="+tab) or "", 
          'user': user, 
          'spc': spc, 
          'folders': folders, 
          "basedirs": [tree.getRoot('home'), tree.getRoot('collections')], 
          'cmenu': getContainerTreeTypes(req), 
          'path': path,
          'language': lang(req),
          't': t,
        }
    
    req.writeTAL("web/edit/edit.html", v, macro="edit_main")

    
def getBreadcrumbs(menulist, tab):
    for menuitem in menulist:
        for item in menuitem.getItemList():
            if item==tab or tab.startswith(item) or item.startswith(tab):
                return [menuitem.getName(),"*"+ item]
    return [tab]

def filterMenu(menuitems, user):
    hide = users.getHideMenusForUser(user)
    ret = []
    for menu in parseMenuString(menuitems):
        i = []
        for item in menu.getItemList():
            if item not in hide:    
                i.append(item)
        menu.item = i
        ret.append(menu)
        
    return ret
    
def handletabs(req, ids, tabs):
    user = users.getUserFromRequest(req)

    n = tree.getNode(ids[0])
    if n.type.startswith("workflow"):
        n = tree.getRoot()
    
    menu = filterMenu(getEditMenuString(n.getContentType()), user)
    
    spc = [Menu("sub_header_frontend", "../", target="_parent")]  
    if user.isAdmin():
        spc.append(Menu("sub_header_administration", "../admin", target="_parent"))
        
    if user.isWorkflowEditor():
        spc.append(Menu("sub_header_workflow", "../publish", target="_parent"))

    spc.append(Menu("sub_header_logout", "../logout", target="_parent"))
    return req.getTAL("web/edit/edit.html", {"user":user, "ids":ids, "idstr":",".join(ids), "menu":menu, "hashelp":help.getHelpPath(['edit', 'modules', req.params.get('tab') or tabs]), "breadcrumbs":getBreadcrumbs(menu, req.params.get("tab", tabs)), "spc":spc}, macro="edit_tabs")

    
def error(req):
    req.writeTAL("<tal:block tal:replace=\"errormsg\"/>",{"errormsg":req.params.get("errmsg","")} , macro="edit_errorpage")
    return athana.HTTP_OK
    
    
# delivers all edit modules
editModules = {} 
def getEditModules(force=0):
    if len(editModules)==0:

        for modpath in core.editmodulepaths: # paths with edit modules
            path = os.walk(os.path.join(config.basedir, modpath[1]))
            for root, dirs, files in path:
                for name in [f for f in files if f.endswith(".py") and f!="__init__.py"]:
                    try:
                        path,module = splitpath(modpath[1])
                        if modpath[0]=='':
                            m = __import__("web.edit.modules." + name[:-3])
                            m = eval("m.edit.modules."+name[:-3])
                        else:
                            sys.path += [path]
                            m = __import__(module.replace("/", ".")+"."+name[:-3])
                            m = eval("m."+name[:-3])
                        editModules[name[:-3]] = m
                    except ImportError as e:
                        print e
                        logger.error("import error in module "+name[:-3])
                    except SyntaxError:
                        logger.error("syntax error in module "+name[:-3])
                        print sys.exc_info()
                        
    return editModules

    
def getIDs(req):
    # update nodelist, if necessary
    if "nodelist" in req.params:
        nodelist = []
        for id in req.params.get("nodelist").split(","):
            nodelist.append(tree.getNode(id))
        req.session["nodelist"] = EditorNodeList(nodelist)

    # look for one "id" parameter, containing an id or a list of ids
    id = req.params.get("id")

    try:
        id = req.params["id"]
    except KeyError:
        pass
    else:
        idlist = id.split(",")
        if idlist != ['']:
            return idlist

    # look for a pattern, a source folder and an id list
    ids = req.params.get('ids', '')

    try:
        srcid = req.params.get("src")
        if srcid == "":
            raise KeyError
        src = tree.getNode(srcid)
    except KeyError:
        src = None

    idlist = ids.split(',')
    if idlist == ['']:
        idlist = []
    return idlist

def nodeIsChildOfNode(node1,node2):
    if node1.id==node2.id:
        return 1
    for c in node2.getChildren():
        if nodeIsChildOfNode(node1, c):
            return 1
    return 0
    

def edit_tree(req):
    access = AccessData(req)

    msg = "%s|req.path=%r|req.params=%r" % (get_user_id(req), req.path, req.params)
    logger.info(msg)

    user = users.getUserFromRequest(req)
    
    if req.params.get('key')=='root':
        nodes = core.tree.getRoot('collections').getContainerChildren().sort_by_orderpos()
    elif req.params.get('key')=='home':

        if not user.isAdmin():
            home_dir = users.getHomeDir(user)
            nodes = [home_dir]  # + home_dir.getContainerChildren().sort_by_orderpos()
        else:
            nodes = tree.getRoot('home').getChildren().sort_by_orderpos()

    else:
        nodes = core.tree.getNode(req.params.get('key')).getContainerChildren().sort_by_orderpos()

    data = []

    for node in nodes:
        #try:
        #    label = node.getLabel()
        #except:
        #    label = node.getName()
        #
        #c = len(node.getContentChildren())
        #if c>0:
        #    label += ' <small>(%s)</small>' %(c)
        
        label = getTreeLabel(node)
            
        nodedata = {'title': label, 'key':node.id, 'isLazy':True, 'isFolder':True, 'icon':'ftree/'+node.getContentType()+'.gif', 'readonly':0, 'tooltip':'%s (%s)' %(node.getName(), node.id)}

        #if req.params.get('key')=='home':
        if node.getName():
            if node.getName().startswith(translate('user_trash', request=req)):
                nodedata['icon'] = "ftree/trashicon.gif"
            elif node.getName().startswith(translate('user_upload', request=req)):
                nodedata['icon'] = "ftree/uploadicon.gif"
            elif node.getName().startswith(translate('user_import', request=req)):
                nodedata['icon'] = "ftree/importicon.gif"
            elif node.getName().startswith(translate('user_faulty', request=req)):
                nodedata['icon'] = "ftree/faultyicon.gif"
            elif node.getName().startswith(translate('user_directory', request=req)):
                nodedata['icon'] = "ftree/homeicon.gif"

        #if hasattr(node, 'treeiconclass'):
        #    nodedata['icon'] = node.treeiconclass()+".gif"
        
        if len(node.getContainerChildren())==0:
            nodedata['isLazy'] = False
            nodedata['children'] = []
            
        if not access.hasWriteAccess(node):
            if req.params.get('key')=='home':
                continue
            nodedata['readonly'] = 1
            nodedata['noLink'] = True
            nodedata['addClass'] = 'readonly'
        else:
            nodedata['readonly'] = 0
            
        # wn 2014-03-14
        # special directories may be handled in a special way by the editor
        special_dir_ids = {}
        homedir = users.getHomeDir(user)
        special_dir_ids[homedir.id] = 'userhomedir'
        for dir_type in ['upload', 'import', 'faulty', 'trash']:
            special_dir_ids[users.getSpecialDir(user, dir_type).id] = dir_type
        #nodedata['special_dir_ids'] = special_dir_ids  # not transmitting ... too much traffic
            
        nodedata['this_node_is_special'] = []
        if node.id in special_dir_ids:
            nodedata['this_node_is_special'] = nodedata['this_node_is_special'] + [special_dir_ids[node.id]]
            
        data.append(nodedata)
    
    return req.write(json.dumps(data, indent=4))

    
def getEditMenuString(ntype, default=0):
    menu_str = ""
    
    for dtype in loadAllDatatypes(): # all known datatypes
        if dtype.name==ntype:
            n = tree.Node("", type=dtype.name)
            
            menu_str = getRoot().get("edit.menu."+dtype.name)
            if (menu_str=="" or default==1) and hasattr(n, "getEditMenuTabs"):
                menu_str = n.getEditMenuTabs()
            break
    return menu_str  
    
def action(req):
    global editModules
    access = AccessData(req)
    user = users.getUserFromRequest(req)
    trashdir = users.getTrashDir(user)
    uploaddir = users.getUploadDir(user)
    faultydir = users.getFaultyDir(user)
    importdir = users.getImportDir(user)
    
    trashdir_parents = trashdir.getParents()
    action = req.params.get("action", "")
    changednodes = {}

    msg = "##### web.edit.edit.action #####"
    logger.debug(msg)

    msg = "%s|%r, %r: req.path=%r|req.params=%r" % (get_user_id(req), __name__, funcname(), req.path, req.params)
    logger.debug(msg)

    if not access.user.isEditor():
        req.write("""permission denied""")
        return
    
    if "tab" in req.params:
        tab = req.params.get("tab").split("_")[-1]
        return editModules[tab].getContent(req, [req.params.get("id")])


    if action == "getlabels":
        nids = req.params.get('ids', [])
        nids = [nid.strip() for nid in nids.split(',') if nid.strip()]
        
        for nid in set(nids + [_n.id for _n in [trashdir, uploaddir, importdir, faultydir]]):
            try:
                changednodes[nid] = getTreeLabel(tree.getNode(nid))
            except:
                msg = "could not make dynatree label for node %r" % nid
                logger.error(msg)    
        res_dict = {'changednodes': changednodes}
        req.write(json.dumps(res_dict, indent=4))   
        return
            
    else:
        # all 'action's except 'getlabels' require a base dir (src)
        srcid = req.params.get("src")
        try:
            src = tree.getNode(srcid)
        except:
            req.writeTAL("web/edit/edit.html", {"edit_action_error":srcid}, macro="edit_action_error")
            return
        
    if req.params.get('action')=='addcontainer':
        node = tree.getNode(srcid)
        if not access.hasWriteAccess(node):
            req.writeTALstr('<tal:block i18n:translate="edit_nopermission"/>', {}) # deliver errorlabel
            return
        # create new container
        newnode_type=req.params.get('type')
        if newnode_type in ['bare_collection', 'bare_directory']:
            newnode_type = newnode_type.replace('bare_', '')
        
        translated_label = t(lang(req), 'edit_add_' + newnode_type)
        if translated_label.startswith('edit_add_'):
            translated_label = t(lang(req), 'edit_add_container_default') + newnode_type
             
        newnode = node.addChild(tree.Node(name=translated_label, type=newnode_type))
        newnode.set("creator", user.getName())
        newnode.set("creationtime",  str(time.strftime( '%Y-%m-%dT%H:%M:%S', time.localtime(time.time()))))
        clearFromCache(node)
        req.params["dest"] = newnode.id
        
        #try:
        #    label = newnode.getLabel()
        #except:
        #    label = newnode.getName()
        #    
        
        try:
            contenttype = newnode.getContentType()
        except:
            contenttype = newnode.type

        #c = len(newnode.getContentChildren())
        #if c>0:
        #    label += ' <small>(%s)</small>' %(c)
        
        label = getTreeLabel(newnode)
            
        dynatree_nodedata = {
           'title': label, 
           'key': newnode.id, 
           'isLazy': False, 
           'isFolder': True,
           'icon': 'ftree/'+contenttype+'.gif',  # check this
           'readonly': 0,
           'tooltip': '%s (%s)' %(newnode.name, newnode.id),
           'children': [],
        }

        req.write(json.dumps(dynatree_nodedata))
        msg = "%s adding new container %r (%r) to %r (%r, %r)" % (access.user.name, newnode.id, newnode.type, node.id, node.name, node.type)
        logging.getLogger('usertracing').info(msg)
        logger.info(msg)
        return        
        
    try:
        destid = req.params.get("dest", None)
        dest = tree.getNode(destid)
        folderid = destid
    except:
        destid = None
        dest = None
        folderid = srcid

    idlist = getIDs(req)
    mysrc = None
    errorobj = None
    
    #try:
    if action=="clear_trash":
        for n in trashdir.getChildren():
            # if trashdir is it's sole parent, remove file from disk
            # attn: this will not touch files from children of deleted containers
            if len(n.getParents()) == 1:
                logger.info("%s going to remove files from disk for node %r (%r, %r)" %(user.getName(), n.id, n.name, n.type))
                for f in n.getFiles():
                    # dangerous ??? check this
                    f_path = f.retrieveFile()
                    if os.path.exists(f_path):
                        logger.info("%s going to remove file %r from disk" %(user.getName(), f_path))
                        os.remove(f_path)
            trashdir.removeChild(n)
            dest = trashdir
        clearFromCache(trashdir)
        changednodes[trashdir.id] = 1    
        _parent_descr = [(p.name, p.id, p.type) for p in trashdir_parents]
        msg = "%s cleared trash folder with id %s, child of %r" %(user.getName(), trashdir.id, _parent_descr)   
        logger.info(msg)
        logging.getLogger('usertracing').info(msg)
        #return
    else:
        for id in idlist:
            obj = tree.getNode(id)
            mysrc = src
    
            if isDirectory(obj):
                mysrc = obj.getParents()[0]
    
            if action=="delete":
                if access.hasWriteAccess(mysrc) and access.hasWriteAccess(obj):
                    if mysrc.id!=trashdir.id:
                        mysrc.removeChild(obj)
                        changednodes[mysrc.id] = 1
                        trashdir.addChild(obj)
                        changednodes[trashdir.id] = 1
                        clearFromCache(mysrc)
                        logger.info("%s moved to trash bin %s (%r, %r) from %s (%r, %r)" %(user.getName(), obj.id, obj.name, obj.type, mysrc.id, mysrc.name, mysrc.type))
                        logging.getLogger('usertracing').info("%s removed %s (%r, %r) from %s (%r, %r)" %(user.getName(), obj.id, obj.name, obj.type, mysrc.id, mysrc.name, mysrc.type))
                        dest = mysrc
                
                else:
                    logger.error("%s has no write access for node %s" %(user.getName(), mysrc.id))
                    req.writeTALstr('<tal:block i18n:translate="edit_nopermission"/>', {})
                dest = mysrc
    
            elif action in ["move", "copy"]:
                
                if dest != mysrc and \
                   access.hasWriteAccess(mysrc) and \
                   access.hasWriteAccess(dest) and \
                   access.hasWriteAccess(obj) and \
                   isDirectory(dest):
                    print "move/copy"
                    if not nodeIsChildOfNode(dest,obj):
                        if action == "move":
                            print "move"
                            mysrc.removeChild(obj)
                            changednodes[mysrc.id] = 1  #getLabel(mysrc)
                        dest.addChild(obj)
                        changednodes[dest.id] = 1  #getLabel(dest)
                        clearFromCache(dest)
    
                        _what = "%s %s %r (%r, %r) "% (access.user.name, action, obj.id, obj.name, obj.type)
                        _from = "from %r (%r, %r) " % (mysrc.id, mysrc.name, mysrc.type)
                        _to = "to %r (%r, %r)" % (dest.id, dest.name, dest.type)
                        msg = _what + _from + _to
                        logging.getLogger('usertracing').info(msg)
                        logger.info(msg)
                        
                    else:
                        logger.error("%s could not %s %s from %s to %s" %(user.getName(), action, obj.id, mysrc.id, dest.id))
                else:
                    return
                mysrc = None
            
    if not mysrc:
        mysrc = src
    #except:
    #    errorobj = sys.exc_info()

    #finally:

    if action in ["move", "copy", "delete", "clear_trash"]:

        for nid in changednodes:
            try:
                changednodes[nid] = getTreeLabel(tree.getNode(nid))
            except:
                msg = "could not make dynatree label for node %r" % nid
                logger.error(msg)    
        res_dict = {'changednodes': changednodes}
        req.write(json.dumps(res_dict, indent=4))    
    else:
        req.write(dest.id)
    return

def showPaging(req, tab, ids):
    nodelist = req.session.get("nodelist", None)
    nextid = previd = None
    position = absitems = '&nbsp;'
    combodata = ""
    script = ""
    if nodelist and len(ids)==1:
        previd = nodelist.getPrevious(ids[0])
        nextid = nodelist.getNext(ids[0])
        position, absitems = nodelist.getPositionString(ids[0])
        combodata, script = nodelist.getPositionCombo(tab)
    v = {"nextid":nextid, "previd":previd, "position":position, "absitems":absitems, "tab":tab,"combodata":combodata, "script":script, "nodeid":ids[0]}
    return req.getTAL("web/edit/edit.html", v, macro="edit_paging")



def get_user_id(req):
    user = users.getUserFromRequest(req)
    #res = "sessionid=%r|isdynamic=%r|userid=%r|username=%r" % (req.sessionid, user.isDynamicUser(), user.getUserID(), user.getName())
    res = "userid=%r|username=%r" % (user.getUserID(), user.getName())
    return res



def dump_args(func):
    "This decorator dumps out the arguments passed to a function before calling it"
    from pprint import pprint as pp, pformat as pf
    argnames = func.func_code.co_varnames[:func.func_code.co_argcount]
    fname = func.func_name
    def echo_func(*args,**kwargs):
        #for entry in zip(argnames,args[:len(argnames)])+[("args",list(args[len(argnames):]))]+[("kwargs",kwargs)]) +")":
        pp(args)
        print '-'*20
        pp(kwargs)
        print '-'*20
        print '###', fname, "(", ', '.join(
            '%s=%r' % entry
            for entry in zip(argnames,args[:len(argnames)])+[("args",list(args[len(argnames):]))]+[("kwargs",kwargs)]) +")"
        return func(*args,**kwargs)
    return echo_func
    
func_calls = []
MAX_FUNC_CALLS_COUNT = 100

def save_func_args(func):
    global func_calls, MAX_FUNC_CALLS_COUNT
    argnames = func.func_code.co_varnames[:func.func_code.co_argcount]
    fname = func.func_name
    def saver_func(*args,**kwargs):
        global func_calls, MAX_FUNC_CALLS_COUNT
        func_calls.append([fname, zip(argnames,args[:len(argnames)])+[("args",list(args[len(argnames):]))]+[("kwargs",kwargs)]])
        if len(func_calls) > MAX_FUNC_CALLS_COUNT:
            func_calls = func_calls[1:]
        return func(*args,**kwargs)
    return saver_func    

from pprint import pprint as pp, pformat as pf
last_req = None
tree.last_editor_req


SID2USER = {}

#@dump_args
@save_func_args   
def content(req):
    
    global SID2USER
    if req.params.get('action', '') == 'upload' and req.params.get('sid', ''):
        user = SID2USER[req.params.get('sid')]
    else:
        user = users.getUserFromRequest(req)
        SID2USER[req.session.id] = user    
        
    access = AccessData(user=user)

    msg = "%s|__name__=%r, func=%r; req.fullpath=%r|req.path=%r|req.params=%r" % (get_user_id(req), __name__, funcname(), req.fullpath, req.path, req.params)
    if 'id' in req.params and len(req.params)==1:
        nid = req.params.get('id')
        try:
            node = tree.getNode(nid)
        except:
            node = None
        if node:    
            cmd = "cd %s (%r, %r)" % (nid, node.name, node.type)
        else:
            cmd = "ERROR-cd to non-existing id=%r" % nid
        msg = msg + '|' + cmd    
    logger.info(msg)
    
    if 'action' in req.params and req.params['action'] == 'upload':
        #import pdb; pdb.set_trace()
        pass
    
    content = {'script':'', 'body':''}
    v = {'dircontent':'', 'notdirectory':0, 'operations':''}

    path = req.path[1:].split("/")
    if len(path)>=4:
        req.params["style"] = "popup"
        req.params["id"] = path[1]
        req.params["tab"] = path[2]
        req.params["option"] = path[3]
    getEditModules()

    if not access.user.isEditor():
        return req.writeTAL("web/edit/edit.html", {}, macro="error")

    # remove all caches for the frontend area- we might make changes there
    for sessionkey in ["contentarea", "navframe"]:
        try:
            del req.session[sessionkey]
        except:
            pass

    ids = getIDs(req)

    if req.params.get("type","")=="help" and req.params.get("tab","")=="upload":
        return upload_help(req)

    if len(ids)>0:
        node = tree.getNode(ids[0])
    tabs = "content"
    if node.type=="root":
        tabs = "content"
    elif node.id==users.getUploadDir(access.getUser()).id:
        tabs = "upload"
    elif node.id==users.getImportDir(access.getUser()).id:
        tabs = "imports"
    elif hasattr(node, "getDefaultEditTab"):
        tabs = node.getDefaultEditTab()
        v["notdirectory"] = 0
        
    # wn 2014-04-15 flash session bug
    if req.params.get('action', '') == 'upload' and req.params.get('sid', ''):
        current = 'upload'
    else:
        current = req.params.get("tab", tabs)
    # some tabs operate on only one file
    #if current in ["files", "view", "upload"]:
    if current in ["files", "upload"]:
        ids = ids[0:1]
        
    msg = "current: %r" % current 
    logger.debug(msg)
    
    # wn 2014-04-24
    if current == 'conlay':
        tabs = current    

    # display current images
    if not tree.getNode(ids[0]).isContainer():
        logger.debug("%s|__name__=%r, func=%r: ----> 01" % (get_user_id(req), __name__, funcname()))
        v["notdirectory"] = 1
        items = []
        if current!="view":
            for id in ids:
                node = tree.getNode(id)
                if hasattr(node, "show_node_image"):
                    if not isDirectory(node) and not node.isContainer():
                        items.append((id, node.show_node_image()))
                    else:
                        items.append(("", node.show_node_image()))
        v["items"] = items
        logger.debug("%s|__name__=%r, func=%r: ----> 02, items: %r" % (get_user_id(req), __name__, funcname(), items))
        try:
            n = tree.getNode(req.params.get('src', req.params.get('id')))
            logger.debug("%s|__name__=%r, func=%r: ----> 03" % (get_user_id(req), __name__, funcname()))
            if current == 'metadata' and 'save' in req.params:
                #import pdb; pdb.set_trace()
                pass
            s = []
            while n:
                s = ['<a target="parent" href="/edit?id=%s">%s</a>' % (n.id,n.name)] + s
                p = n.getParents()
                if p: n = p[0]
                else: n = None
            v["dircontent"] = ' <b>&raquo;</b> '.join(s[1:])
        except:
            logger.warning('exception 001')    
            
    else: # or current directory
        n = tree.getNode(ids[0])
        s = []
        while n:
            if len(s)==0:
                s = ['%s' % (n.name)]
            else:
                s = ['<a target="parent" href="/edit?id=%s">%s</a>' % (n.id,n.name)] + s
            p = n.getParents()
            if p: n = p[0]
            else: n = None
        v["dircontent"] = ' <b>&raquo;</b> '.join(s[1:])

    if current=="globals":
        basedir = config.get("paths.datadir")
        file_to_edit = None
        
        if "file_to_edit" in req.params:
            file_to_edit = req.params["file_to_edit"]
            
        if not file_to_edit:
            d = node.getStartpageDict()
            if d and lang(req) in d:
                file_to_edit = d[lang(req)]

        found = False
        for f in node.getFiles():
            if f.mimetype=='text/html':
                filepath = f.retrieveFile().replace(basedir, '')
                if file_to_edit == filepath:
                    found = True
                    result = edit_editor(req, node, f)
                    if result == "error":
                        print "error editing ", f.retrieveFile()
                    break

        if not found:
            edit_editor(req, node, None)
            
    elif current == "tab_metadata":
        edit_metadata(req, ids)
    elif current == "tab_upload":
        edit_upload(req, ids)  # undefined
    elif current == "tab_import":
        edit_import(req, ids)
    elif current == "tab_globals":
        req.write("")
    elif current == "tab_lza":
        edit_lza(req, ids)
    elif current == "tab_logo":
        edit_logo(req, ids)
    else:
        msg = "#temp#%s|__name__=%r, func=%r; current=%r ---> else" % (get_user_id(req), __name__, funcname(), current)
        logger.debug(msg)
        t = current.split("_")[-1]
        if t in editModules.keys():
            c = editModules[t].getContent(req, ids)
            if c:
                content["body"] += c # use standard method of module
            else:
                return
            #content["body"] += editModules[t].getContent(req, ids) # use standard method of module
            #print "use standard body", t
        else:
            content["body"] += req.getTAL("web/edit/edit.html",{"module":current}, macro="module_error")

    if req.params.get("style","")!="popup": # normal page with header
        v["tabs"] = handletabs(req, ids, tabs)
        v["script"] = content["script"]
        v["body"] = content["body"]
        v["paging"] = showPaging(req, current, ids)
        v["node"] = node
        v["ids"] = req.params.get("ids", "").split(",")
        if req.params.get("ids", "")=="":
            v["ids"] = req.params.get("id", "").split(",")
        v["tab"] = current
        v["operations"] = req.getTAL("web/edit/edit_common.html", {'iscontainer':node.isContainer()}, macro="show_operations")
        user = users.getUserFromRequest(req)
        v['user'] = user
        v['language'] = lang(req)
        v['t'] = translation_t
        
        v['spc'] = [Menu("sub_header_frontend", "../", target="_parent")]  
        if user.isAdmin():
            v['spc'].append(Menu("sub_header_administration", "../admin", target="_parent"))
            
        if user.isWorkflowEditor():
            v['spc'].append(Menu("sub_header_workflow", "../publish", target="_parent"))

        v['spc'].append(Menu("sub_header_logout", "../logout", target="_parent"))
        
        #msg = pf(v)
        #logger.debug(msg)
        return req.writeTAL("web/edit/edit.html", v, macro="frame_content")


def printmethod(req):
    getEditModules()
    if req.params.get("module") in editModules.keys():
        mod = editModules[req.params.get("module")]
        return mod.getPrintView(req)
